# Доп. задание
1. Построить грамматику для языка `{a^{m} b^{n+m} | m >= 1, 0 <= n <= m}`        
   Этот язык совпадает с языком `L = {a^{m} b^{n} | m >= 1, m <= n <= 2m}`    
    `S -> X | Y`     
    `X -> aXbb | aYbb | abb`    
    `Y -> ab | aYb`    
    Что вообще здесь происходит? Сначала мы x >= 0 раз переходим по правилу `X`,  а потом y >= 0 раз переходим по правилу `Y`, при этом мы пройдем хотя бы один раз по `X` или `Y`.    
    Какие слова будут лежать в грамматике? x раз мы добавляем в начало `a` и в конец `bb`, потом y раз добавляем в начало `a` и в конец `b`.     
    n = Количество символов `b` = 2x + y, m = количество символов `a` = x + y.     
    => `m <= n <= 2m`. Обе оценки очевидно достигаются, то что нам нужно.    
    Такая грамматика - однозначная. По n и m можем однозначно восстановить x и y.      

    P.S. Можно было сделать намного проще: `S -> abb | ab | aSbb | aSb`

    Я сделал такую грамматику, потому что я долго пытался подобрать грамматику, подходящую под задание №3.    
    Спойлер: у меня не получилось.    

2. Проверить, принадлежит ли эта грамматика классу LL(1).    
`FIRST(Y) = {'a'}`    
`FIRST(X) = {'a'}`    
`FOLLOW(Y) = {'b', '$'}`    
`FOLLOW(X) = {'b', '$'}`    
Пересечение `FIRST(X)` и `FIRST(Y)` != пустому множеству. Значит не LL(1) грамматика.    

3. Проверить, принадлежит ли эта грамматика классу LR.    
Ответ: Нет.    
Докажем, что наша грамматика не лежит в LR(k) для любого k.        
Пусть лежит в каком-то LR(k). Тогда мы можем построить LR автомат и таблицу для неё.     
Возьмем строку s, где лежит очень много букв 'a' (намного больше, чем k), а значит и букв 'b'. Пусть наш алгоритм корректно выводит эту строку.   
Как 'работает' наша грамматика - мы сначала x раз используем правило `X`, потом y раз правило `Y`. В какой-то момент мы должны понять, что нам нужно перейти из X в Y.    
Добавим в конец нашей строки некоторое количество букв `b` или выкинем из конца, если их уже слишком много. Тогда позиция, где нужно переходить из правила X в правило Y - сместится.    
Заметим, что поведение нашего алгоритма до какого-то момента не будет отличаться поведения алгоритма на s, так как он не зависит от далеко стоящих (на расстоянии намного больших, чем k) букв b. Позиция перехода из X в Y сместится, а алгоритм этого не заметит, значит он ошибётся, так как у нас грамматика однозначная и других выводов нет.